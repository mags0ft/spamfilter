{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Delivering streamlined, customizable spam mitigations into any environment.</p>"},{"location":"#welcome-to-spamfilter","title":"Welcome to spamfilter!","text":"<p>The spamfilter module is a lightweight, concise way to protect applications against text spam when processing user-generated content.</p> <p>\ud83d\udc49 Get started | \ud83d\udcd5 Documentation | \ud83d\udc69\u200d\ud83d\udcbb Install | \ud83d\ude38 GitHub</p>"},{"location":"#how-spamfilter-is-built","title":"How spamfilter is built","text":"<ul> <li>\ud83c\udfa8 Highly modular - everything in the module is reusable, from algorithms over pipelines to blueprint classes. Build your own, perfect spam filter model using the modular built-in classes.</li> <li>\u2728 Premade filtering pipelines - the module comes with a variety of premade models that are ready to be dropped into your environment, optimized for each usecase.</li> <li>\ud83d\udc49 Built-in algorithms - with 10+ spam detection algorithms built right into the module, you can create your high-accuracy filter within seconds.</li> <li>\u2699\ufe0f Customizable spam handling - you decide how spam should be handled. The spamfilter package can censor, mitigate or even dismiss spam on its own.</li> <li>\ud83d\udc0d Built with typed, documented python - written in highest, modern python standards, spamfilter is easy to understand for new users.</li> <li>\ud83d\udca1 Self-explanatory - every class or method has docstrings attached to it, the variable names are held simple and the project is fully open-source.</li> </ul>"},{"location":"#where-to-get-started","title":"Where to get started","text":"<p>It's super easy to get started with spamfilter! The module is designed to be intuitive and user-friendly, so you can quickly implement it in your projects.</p> <p>Check out the Get started guide to learn how to install and use it!</p>"},{"location":"ai_and_ml/","title":"Artificial Intelligence (AI) and Machine Learning (ML) in spam filtering","text":"<p>The <code>spamfilter</code> package provides several methods to integrate Artificial Intelligence (AI), more specifically, Machine Learning (ML) into the spam filtering process. This allows for more accurate and modern spam filtering techniques to be used in your pipelines.</p> <p>However, these do not come without risk; please make sure to have read the following disclaimer before using any of these features.</p>"},{"location":"ai_and_ml/#things-to-consider-before-integrating-ai","title":"Things to consider before integrating AI","text":"<p>Before adding any AI-based spam filtering methods, please consider the following:</p> <ul> <li>is your project or use case of reasonable scale for the application of these technologies? If your project is rather small and short on budget, compute can become unreasonably expensive.</li> <li>can you solve the problem without uselessly integrating AI as a buzzword? You don't need to use AI for everything, and sometimes simpler solutions are more effective, dramatically faster and resource-efficient.</li> <li>did you consider the license of the AI model you picked for spam filtering? If you don't have the rights to use the model, you might be violating the license and can be held liable for it.</li> </ul>"},{"location":"ai_and_ml/#how-to-get-started-correctly","title":"How to get started, correctly","text":"<p>Don't just add the <code>MLTextClassifier</code> into your pipeline and call it a day. AI models can be...</p> <ul> <li>big to download, slowing down spin-up time of your application when frequently re-deployed</li> <li>expensive to run, especially if you use a large model or a lot of data</li> <li>bad for the environment if run for several hundreds of thousand times per day</li> </ul> <p>You can use techniques like making use of the <code>normal-quick</code> mode in pipelines to stop evaluation as soon as any filter detects a problem, which would eliminate the need to call any more expensive filters (like the ones using AI).</p> <p>You should also make sure that the models used in your filters are well-trained, not too large and suitable for the task. The <code>MLTextClassifier</code>, for example, uses a model to detect hate speech and may not be suited for detecting spam in emails.</p>"},{"location":"ai_and_ml/#available-ai-based-filters","title":"Available AI-based filters","text":"<p>There are three main filters that you may want to use in order to integrate AI into your spam filtering pipeline:</p> <ul> <li><code>MLTextClassifier</code>: A text classifier that uses a pre-trained model to classify text as spam or not spam. It is based on the <code>transformers</code> library and requires a model to be downloaded.</li> <li><code>Ollama</code>: A filter that uses the Ollama API to classify text as spam or not spam. It requires an Ollama server to be running and accessible, is even more expensive than the <code>MLTextClassifier</code> and should only be used if you have a good reason to do so, for example, correcting harmful text to non-harmful text.</li> <li><code>API</code>: A general-purpose filter you may want to use in order to call third-party APIs to classify text as spam or not spam. This is a very flexible filter that can be used to integrate any API that returns a classification result.</li> </ul>"},{"location":"contributing/","title":"\ud83d\udc69\u200d\ud83d\udcbb Contributing","text":"<p>No matter whether you're an active contibutor at <code>spamfilter</code> or just browsing around, we're happy to see everyone engage and could really use some help!</p> <ul> <li> <p>\ud83d\udca1 Do you have ideas for new features? Go here!</p> </li> <li> <p>\ud83d\udc1e Found any bugs? Go here!</p> </li> <li> <p>\ud83d\udd13 Do you want to disclose a security vulnerability? Click here.</p> </li> <li> <p>\u26a1 Write your own code for the module? Feel free to do so and please continue to read to the next section!</p> </li> </ul>"},{"location":"contributing/#contribute-own-code","title":"Contribute own code","text":"<p>You're always welcome to build new features, filters and options into the <code>spamfilter</code> module! We love to see what you got to contribute to the package. Please follow these few rules of thumb:</p> <ul> <li>run <code>pytest</code> and <code>pylint $(git ls-files *.py)</code> once you like to publish your changes.</li> <li>create a custom fork to push your changes to, then create a pull request on GitHub!</li> <li>get your code reviewed to ensure your code is alright, fast and great to use for the users of <code>spamfilter</code>!</li> </ul>"},{"location":"documentation/","title":"\ud83d\udcd5 Documentation","text":"<p>Welcome to the <code>spamfilter</code> module's documentation!</p> <p>Here you will find classes, concepts and methods explained hat high-level detail for your next use of the package.</p>"},{"location":"documentation/#links","title":"Links","text":"<p>General information page links:</p> <ul> <li>Get started</li> <li>Installation</li> <li>How to contribute</li> </ul> <p>Code documentation links:</p> <ul> <li>spamfilter.filters</li> <li>spamfilter.pipelines</li> <li>spamfilter.results</li> <li>spamfilter.premade</li> </ul> <p>If you're missing some documentation, feel free to reach out to the contributor(s) via GitHub!</p>"},{"location":"filters/","title":"\ud83d\udce2 filters","text":"<p>The spamfilter module comes with many built-in filtering algorithms that can determine whether a string is spam or rather not. In this document, all of these filters will be listed.</p>"},{"location":"filters/#how-to-import-filters","title":"How to import filters","text":"<p>There are a lot of ways to import the filters you need. If you just want to use a pre-made model for filtering, you don't need to import them at all, they are going to be imported into the module by itself - just use <code>spamfilter.premade</code>.</p> <p>If you want to import the built-in filters into your script, do it using one of the following ways:</p> <p>For one single filter:</p> <pre><code>from spamfilter.filters import Filter\n</code></pre> <p>For several filters:</p> <pre><code>from spamfilter.filters import (\n    Capitals,\n    Length,\n    SpecialChars\n)\n</code></pre> <p>For all filters</p> <pre><code>from spamfilter.filters import *\n</code></pre> <p>Please note that wildcard imports are generally not recommended and may raise linter warnings.</p>"},{"location":"filters/#all-filters-explained","title":"All filters explained","text":"<p>Generally, all filters are stacked onto each other using a pipeline object which will then check them one after each other.</p> <p>You construct a filter like this:</p> <pre><code>Filter(**options, mode = \"normal\")\n</code></pre> <p>Each filter also has a <code>check(string: str)</code> method which accepts a string as an input and will return the filter's assesment of it using the options given at construction as a tuple.</p> <p>The tuple is built as following:</p> <pre><code>(passed: int, output_string: str)\n</code></pre> <ul> <li>passed indicated whether the string did complete the check successfully and therefore wasn't indicated as spam.</li> <li>output_string is the string returned by the filter as it might do corrections on it like lower-casing all letters in case it contains too many capital letters.</li> </ul> <p>Note: The default regex used by the <code>Email</code> filter is <code>([a-zA-Z0-9+._-]+@[a-zA-Z0-9._-]+\\.[a-zA-Z0-9_-]+)</code>.</p> <p>Note: The default response parsing function is the following:</p> <pre><code>def _default_response_parsing_function(\n    result: list[dict[str, Union[str, float]]],\n) -&gt; bool:\n    \"\"\"\n    Default response parsing function that checks if the label\n    is 'spam' or 'toxic'.\n    \"\"\"\n\n    sorted_result = sorted(result, key=lambda x: x[\"score\"], reverse=True)\n    top_label: str = str(sorted_result[0][\"label\"]).lower()\n\n    return top_label not in [\"spam\", \"toxic\", \"hate\", \"abusive\"]\n</code></pre>"},{"location":"filters/#spamfilter.filters.Filter","title":"<code>spamfilter.filters.Filter</code>","text":"<p>The filter base class the other filters inherit from.</p> <ul> <li><code>Filter.check(string: str)</code>: check a string against this filter.</li> </ul>"},{"location":"filters/#spamfilter.filters.Filter.check","title":"<code>check(string: str) -&gt; tuple[bool, str]</code>","text":"<p>Checks if a given string passes the filter's criteria.</p> <p>Returns a tuple containing a boolean (whether it passed) and optionally a string (modified version of the input string made by the filter to mitigate errors - might not be given, depending on the mode selected).</p> <p>The base Filter class does not modify the string, so it always returns <code>True</code> and the original string. Any other filter that inherits from this class should override this method to implement its specific filtering logic.</p>"},{"location":"filters/#spamfilter.filters.SpecialChars","title":"<code>spamfilter.filters.SpecialChars</code>","text":"<p>               Bases: <code>Filter</code></p> <p>Check if a string contains too many special characters.</p> <ul> <li><code>SpecialChars.percentage</code>: how many percent of the text need to be special characters for it to fail.</li> <li><code>SpecialChars.mode</code>: how to handle a failing string.<ul> <li><code>normal</code>: fail the string if it contains too many special characters</li> <li><code>crop</code>: remove all special characters from the string if it would fail, but then make the string pass.</li> </ul> </li> <li><code>SpecialChars.symboldef</code>: what to identify as a symbol<ul> <li><code>explicit</code>: everything that matches <code>SpecialChars.specialcharset</code>.</li> <li><code>implicit</code>: everything that does not match <code>SpecialChars.charset</code>.</li> </ul> </li> <li><code>SpecialChars.abs_safe_min</code>: absolute amount of special characters that are always okay to use.</li> </ul> <p>Was called \"Symbols\" prior to v2.0.0, which was a breaking change.</p>"},{"location":"filters/#spamfilter.filters.Capitals","title":"<code>spamfilter.filters.Capitals</code>","text":"<p>               Bases: <code>Filter</code></p> <p>Check if a string contains too many capital letters.</p> <ul> <li><code>Capitals.percentage</code>: how many percent of the text need to be in capital for it to fail.</li> <li><code>Capitals.abs_safe_min</code>: the absolute amound of capital characters that are always okay. Set to -1 to deactivate.</li> <li><code>Capitals.mode</code>: how to handle a failing string.<ul> <li><code>normal</code>: fail the string</li> <li><code>crop</code>: crop all letters to lowercase if the string is too capital, makes it always pass</li> </ul> </li> </ul>"},{"location":"filters/#spamfilter.filters.Length","title":"<code>spamfilter.filters.Length</code>","text":"<p>               Bases: <code>Filter</code></p> <p>Checks if a string matches given length requirements.</p> <ul> <li><code>Length.min</code>: The inclusive minimum length.</li> <li><code>Length.max</code>: The inclusive maximum length.</li> <li><code>Length.padding</code>: A character used to fill up strings that are too short in the <code>crop</code> mode.</li> <li><code>Length.mode</code>: How to handle failing strings.<ul> <li><code>normal</code>: Fail too short or too long strings.</li> <li><code>crop</code>: Shorten too long strings and fill too short strings up using <code>Length.padding</code>.</li> </ul> </li> </ul>"},{"location":"filters/#spamfilter.filters.Blocklist","title":"<code>spamfilter.filters.Blocklist</code>","text":"<p>               Bases: <code>Filter</code></p> <p>Filter text for blocked words. Works better in combination with <code>BypassDetector</code>.</p> <ul> <li><code>Blocklist.mode</code>: How to handle incoming text.<ul> <li><code>normal</code>: search for profane words adjacent to punctuation or spaces.</li> <li><code>strict</code>: search for any occurence of a profane word. WARNING: this might detect words like \"classic\" as they contain parts of a profane words.</li> <li><code>tolerant</code>: simply replace the problematic words.</li> </ul> </li> <li><code>Blocklist.blocklist</code>: a set with words that shall be blocked.</li> <li><code>Blocklist.ignore_regex</code>: a regular expression that matches punctuation characters for splitting the string in non-strict mode.</li> <li><code>Blocklist.profanity_replacement</code>: what to replace profanity with.</li> </ul>"},{"location":"filters/#spamfilter.filters.BlocklistFromJSON","title":"<code>spamfilter.filters.BlocklistFromJSON</code>","text":"<p>               Bases: <code>Blocklist</code></p> <p>Behaves just like the <code>Blocklist</code> class. Reads a JSON list and inserts it's content into the <code>Blocklist.blocklist</code> property.</p> <ul> <li><code>BlocklistFromJSON.file</code>: filename of JSON file.</li> </ul>"},{"location":"filters/#spamfilter.filters.API","title":"<code>spamfilter.filters.API</code>","text":"<p>               Bases: <code>Filter</code></p> <p>JSON API-based, synchronous spam filter. Requires installation with the optional API dependencies: <code>pip install spamfilter[api]</code>.</p> <p>If using AI/ML, please make sure to have read the warnings in the documentation.</p> <ul> <li><code>API.url</code>: API URL to call.</li> <li><code>API.headers</code>: dictionary of headers to pass to the API</li> <li><code>API.method</code>: whether to use GET (<code>get</code>) or POST (<code>post</code>)</li> <li><code>API.payload_func</code>: function called before the request to the API is sent; needs to convert the passed argument, the text string, to a dictionary with the correct payload format used by your API of choice.</li> <li><code>API.interpretation_func</code>: function called after the response arrives; gets the JSON response passed to it and needs to figure out if the filter shall pass. Needs to return a tuple of a boolean and the modified string.</li> <li><code>API.timeout</code>: After how many seconds the request to the API shall time out.</li> <li> <p><code>API.mode</code>: currently, only \"normal\" is supported.</p> </li> <li> <p><code>API.check(string: str)</code>: send this string to the API and check the response JSON against the provided</p> </li> </ul>"},{"location":"filters/#spamfilter.filters.Regex","title":"<code>spamfilter.filters.Regex</code>","text":"<p>               Bases: <code>Filter</code></p> <p>Check if a string matches a given regular expression.</p> <ul> <li><code>Regex.mode</code>: how to handle a failing string.<ul> <li><code>normal</code>: fail the string.</li> <li><code>censor</code>: censor the match.</li> </ul> </li> <li><code>Regex.regex</code>: the regex used to check for matches.</li> <li><code>Regex.replacement</code>: what regex to replace matches with.</li> </ul> <p>Was called \"PersonalInformation\" prior to v2.0.0, which was a breaking change.</p>"},{"location":"filters/#spamfilter.filters.Email","title":"<code>spamfilter.filters.Email</code>","text":"<p>               Bases: <code>Regex</code></p> <p>Check if a string contains an email address.</p> <ul> <li><code>Email.mode</code>: how to handle a failing string.<ul> <li><code>normal</code>: fail the string.</li> <li><code>censor</code>: censor the information.</li> </ul> </li> <li><code>Email.regex</code>: the regex used to check for email addresses.</li> <li><code>Email.replacement</code>: what regex to replace email addresses with.</li> </ul>"},{"location":"filters/#spamfilter.filters.Ollama","title":"<code>spamfilter.filters.Ollama</code>","text":"<p>               Bases: <code>Filter</code></p> <p>A filter that connects to an Ollama API endpoint to check if a given string is spam or not. This might introduce significant latency in your pipeline, so use this with caution and only if necessary.</p> <p>Please make sure to have read the warnings in the documentation.</p> <p>This filter requires the <code>ollama</code> Python package to be installed, which can be done with <code>pip install spamfilter[ollama]</code>.</p> <ul> <li><code>Ollama.model</code>: the model to use for checking spam.</li> <li><code>Ollama.mode</code>: how to handle a failing string.<ul> <li><code>normal</code>: fail the string.</li> <li><code>correcting</code>: correct the string if it is spam, always allow it</li> </ul> </li> <li><code>Ollama.host</code>: the host of the Ollama API endpoint.</li> <li><code>Ollama.prompt</code>: the prompt to use for the LLM.</li> <li><code>Ollama.json_schema</code>: the json schema to use for formatted outputs.</li> <li><code>Ollama.options</code>: the options to use for the Ollama API request.</li> <li><code>Ollama.thinking</code>: whether to enable thinking mode for the LLM.</li> <li><code>Ollama.response_parsing_function</code>: a function that takes the response   from the Ollama API and returns a tuple of a boolean (whether it is spam)   and the potentially corrected string.</li> </ul> <p>It is highly recommended to adjust most of these paramters to your needs, especially the <code>Ollama.model</code> and <code>Ollama.prompt</code> parameters.</p>"},{"location":"filters/#spamfilter.filters.Ollama.check","title":"<code>check(string: str) -&gt; tuple[bool, str]</code>","text":"<p>Sends the given string to the Ollama API and checks if it is spam or not. Returns a tuple of a boolean (whether it is spam) and the potentially corrected string.</p>"},{"location":"filters/#spamfilter.filters.MLTextClassifier","title":"<code>spamfilter.filters.MLTextClassifier</code>","text":"<p>               Bases: <code>Filter</code></p> <p>A filter that instantiates a \ud83e\udd17 Transformers text classification pipeline and uses it to classify text as spam or not. Note that machine learning is never 100% accurate, so this filter may not always return the correct result and let harmful content through.</p> <p>Please make sure to have read the warnings in the documentation.</p> <p>This filter requires the <code>transformers</code> Python package to be installed, which can be done with <code>pip install spamfilter[transformers]</code>.</p> <ul> <li><code>MLTextClassifier.__init__.model</code>: the model to use for checking spam.</li> <li><code>MLTextClassifier.mode</code>: how to handle a failing string.<ul> <li><code>normal</code>: fail the string.</li> </ul> </li> <li><code>MLTextClassifier.response_parsing_function</code>: a function that   parses the response from the model and returns a boolean indicating   whether the string is spam or not.</li> </ul> <p>WARNING: The standard model is a hate detection model which will be automatically pulled from Hugging Face (~ 500 MB). You may want to use a more suitable model for your use case, such as a custom spam detection model for email spam detection.</p>"},{"location":"filters/#spamfilter.filters.MLTextClassifier.check","title":"<code>check(string: str) -&gt; tuple[bool, str]</code>","text":"<p>Checks if the given string is spam or not using the text classification model specified in <code>self.model</code>.</p> <p>It will not alter the string in any way - if you need corrections, use the <code>Ollama</code> filter instead.</p>"},{"location":"filters/#incorporating-these-filters","title":"Incorporating these filters","text":"<p>If you want to use these filters, please don't use them roughly as <code>Filter</code> instance but rather wrapped into a <code>Pipeline</code> object.</p>"},{"location":"get_started/","title":"Getting started","text":"<p>You can easily get started with <code>spamfilter</code> as it's quick to pick up and easy to understand.</p> <p>\ud83d\udd25 First of all, you should install the module by following these steps.</p> <p>You can then validate if the install was successful by running the Python console and typing:</p> <pre><code>&gt;&gt;&gt; import spamfilter\n&gt;&gt;&gt; spamfilter.__version__\n'v2.1.0'\n&gt;&gt;&gt; \n</code></pre> <p>You may also try to play around with the built-in, premade pipelines to test how good <code>spamfilter</code> keeps user-generated content clean. Create a new file and paste the following code:</p> <pre><code>from spamfilter.premade import chat\n\nc = chat.create_pipeline()\n\nINPUT_STRING = \"This is a test string.\"\nprint(c.check(INPUT_STRING).passed)\n</code></pre> <p>By running the file, you see how the pre-made model assessed the input string. <code>True</code> corresponds for the string to have passed and therefore not being spam according to the model. <code>False</code> corresponds for the string to have failed the filter and being spam.</p> <p>Awesome! You're all set. See the documentation to continue.</p>"},{"location":"installation/","title":"Installation","text":"<p>In this document, you will learn how to install the <code>spamfilter</code> module. There are generally three options to get started.</p>"},{"location":"installation/#how-to-install","title":"\ud83d\udc49 How to install","text":"<p>You may install the module using <code>pip</code>, which is the easiest way to do it as <code>spamfilter</code> is in the PyPI index.</p> <p>To achieve this, run</p> <pre><code>pip install spamfilter\n</code></pre> <p>in your terminal. If that doesn't work, for example due to <code>pip</code> not being added to your PATH, just try</p> <pre><code>python3 -m pip install spamfilter\n</code></pre> <p>instead.</p>"},{"location":"installation/#extra-dependencies","title":"Extra dependencies","text":"<p>If you plan to use spamfilter with third-party API calling support, run</p> <pre><code>pip install spamfilter[api]\n</code></pre> <p>If you want to use the Ollama integration, run</p> <pre><code>pip install spamfilter[ollama]\n</code></pre> <p>If you want to take advantage of machine learning text classification using \ud83e\udd17 Transformers, run</p> <pre><code>pip install spamfilter[transformers]\n</code></pre> <p>If you want to install development dependencies, run</p> <pre><code>pip install spamfilter[dev]\n</code></pre>"},{"location":"installation/#other-installation-methods","title":"Other installation methods","text":"<p>You can also install <code>spamfilter</code> without using the Python package index and instead install the source files locally. This can be achieved using this website's download links at the very top or the files available at the GitHub repository.</p> <p>Place the <code>.zip</code> or <code>.tar.gz</code>-files into your project folder, unpack them and move the <code>src</code> folder into your project root.</p> <p>\ud83d\udea9 Note that the manual install using download is not recommended because it's way less optimized, bloated with unnecessary files and hard to do.</p>"},{"location":"pipelines/","title":"\ud83c\udfa8 The <code>Pipeline</code> class","text":"<p>Pipelines in <code>spamfilter</code> allow you to customize own models that periodically work through the filters wrapped into them.</p> <p>Please note: Prior to <code>spamfilter</code> v2.0.0, the pipelines were called \"machines\". This is no longer the case, as we figured the term \"machine\" is not fully accurate for the way they work. The term \"pipeline\" is the new standard, as it describes the process of passing data through a series of filters. Thus, <code>spamfilter</code> v2.0.0 is a breaking change and you will need to update your code if you used machines before.</p>"},{"location":"pipelines/#how-to-import-the-pipeline-class","title":"How to import the pipeline class","text":"<p>To import the class of a Pipeline, simply run:</p> <pre><code>from spamfilter.pipelines import Pipeline\n</code></pre>"},{"location":"pipelines/#pipelines-explained","title":"Pipelines explained","text":"<p>Generally, all filters are stacked onto each other using a pipeline object which will then check them one after each other.</p> <p>A pipeline implements a <code>check(string: str)</code> method which accepts a string as an input and will return a <code>results.Result</code> object. This object contains info about the filtering run, a.e. whether the string passed all tests and how it has been altered.</p> <p>Check the documentation for <code>results.Result</code> for more information about the Result object.</p> <p>Filters may modify the strings they get as input, depending on the filter and pipeline mode. The pipeline will pass the modified strings from one filter to the next ones:</p> <p>[THIS IS A CAPITAL STRING]</p> <p>\u2b07</p> <p>[<code>Capitals</code> filter]</p> <p>\u2b07</p> <p>[this is a capital string]</p> <p>\u2b07</p> <p>[other filters...]</p>"},{"location":"pipelines/#spamfilter.pipelines.Pipeline","title":"<code>spamfilter.pipelines.Pipeline</code>","text":"<p>A pipeline is an object that accepts several filters and passes strings through these. It's the core mechanism to filter potential spam strings.</p> <ul> <li><code>Pipeline.filters</code>: this property is a list of all filters in a pipeline. The order is kept.</li> <li><code>Pipeline.mode</code>: can either be <code>\"normal\"</code>, <code>\"tolerant</code>\" or <code>\"zero-tolerance\"</code>.<ul> <li><code>\"normal\"</code> lets filters change the string itself and will make strings fail if a filter says so.</li> <li><code>\"normal-quick\"</code> is like normal, but stops execution as soon as a fail happens.</li> <li><code>\"tolerant</code>\" passes strings, no matter what filters say, and does not stop execution of them on fail.</li> <li><code>\"zero-tolerance\"</code> does not accept any changes to a string and fails it as soon as a filter registers something.</li> </ul> </li> </ul> <p>Was called \"Machine\" prior to v2.0.0, which was a breaking change.</p>"},{"location":"pipelines/#spamfilter.pipelines.Pipeline.__init__","title":"<code>__init__(filters: PipelineFilterType = None, mode: str = 'normal')</code>","text":"<p>Initializes the Pipeline object for later use. Filters do not need to be passed at this stage, they can be added later on.</p> <p>Modes <code>normal</code>, <code>normal-quick</code>, <code>tolerant</code> and <code>zero-tolerance</code> are supported.</p>"},{"location":"pipelines/#spamfilter.pipelines.Pipeline.check","title":"<code>check(string: str) -&gt; Result</code>","text":"<p>Checks a given string against the filters inside the Pipeline. Returns a <code>Result</code> object.</p>"},{"location":"pipelines/#an-example","title":"An example","text":"<p>This is an example of how you could implement three filters into one pipeline, which will check the string of them through each of the given filters.</p> <pre><code>from spamfilter.pipelines import Pipeline\nfrom spamfilter.filters import (\n    Capitals,\n    SpecialChars,\n    Length\n)\n\nm = Pipeline([\n    Capitals(),\n    SpecialChars(mode = \"crop\"),\n    Length(min_length = 20, max_length = 60)\n])\n\nprint(\n    m.check(\"Test string!\").passed\n)\n</code></pre>"},{"location":"premade/","title":"\ud83c\udf70 Pre-made pipelines","text":"<p>There are pre-made collections of usecase-optimized filters built into <code>spamfilter</code>. Those are made to fit right into the environment they are made for and don't need additional setup in most cases.</p>"},{"location":"premade/#how-to-use-a-pre-made-pipeline","title":"How to use a pre-made pipeline","text":"<p>To use a pre-made pipeline, do the following (this example is using the <code>chat</code> pipeline):</p> <pre><code>from spamfilter.premade import chat\n\nc1 = chat.create_pipeline(...args)\nc2 = chat.chatPipeline\n</code></pre> <p><code>c1</code> is a pipeline created using <code>create_pipeline</code>, a function that accepts arguments depending on the pre-made pipelines you chose.</p> <p><code>c2</code> is a ready-to-use, default-setup pipeline object that runs immediately.</p> <p>You can now use the functions of pipelines you know, such as <code>check</code>.</p> <p>\u26a0 Warning! Always extensively test pre-made pipelines for their accuracy as this might depend on your usecase. You want the least amount of spammy content to pass through them, so you might do some adjustments to the <code>create_pipeline</code> function instead of using the ready-to-go-options right away.</p> <p>Filters built in:</p> <ul> <li><code>Length</code>,</li> <li><code>WorldLength</code>,</li> <li><code>SpecialChars</code>,</li> <li><code>Capitals</code>,</li> <li><code>BypassDetector</code>,</li> <li><code>BlocklistFromJSON</code> (inactive by default)</li> </ul> <p>This pipeline does already pretty good to block awful spam from your environment. It is also set to be running in <code>normal-quick</code> pipeline mode, meaning it cancels out any additional checks and sanitation as soon as a filter marks the string as failed.</p>"},{"location":"premade/#spamfilter.premade.chat","title":"<code>spamfilter.premade.chat</code>","text":"<p>The module containing a pre-made Pipeline class for chat message filtering.</p>"},{"location":"premade/#spamfilter.premade.chat.create_pipeline","title":"<code>create_pipeline(bypass_protection: bool = True, length_filter: bool = True, min_length: int = 1, max_length: int = 200, wordlength_filter: bool = True, max_word_length: int = 20, max_num_too_long_words: int = 1, capitals_filter: bool = True, capitals_percentage: float = 0.3, capitals_mode: str = 'crop', specialchars_filter: bool = True, profanity_filter: bool = False, profanity_blocklist_filepath: str = '')</code>","text":"<p>Create a Pipeline that is pre-made to be used in fast-paced, internet chatting environments.</p>"},{"location":"premade/#using-premadechat","title":"Using premade.chat","text":"<p>Create a Pipeline that is pre-made to be used in fast-paced, internet chatting environments.</p> <p>If you want to fine-tune your pipeline with <code>create_pipeline</code>, you are free to adjust these arguments:</p> <pre><code>from spamfilter.premade import chat\n\nc = chat.create_pipeline(\n    bypass_protection: bool = True,\n    length_filter: bool = True,\n    min_length: int = 1,\n    max_length: int = 200,\n    wordlength_filter: bool = True,\n    max_word_length: int = 20,\n    max_num_too_long_words: int = 1,\n    capitals_filter: bool = True,\n    capitals_percentage: float = 0.3,\n    capitals_mode: str = \"crop\",\n    specialchars_filter: bool = True,\n    profanity_filter: bool = False,\n    profanity_blocklist_filepath: str = \"\"\n)\n</code></pre> <p>If you want to use a default, no-setup and maybe less optimized pipeline, go for:</p> <pre><code>from spamfilter.premade import chat\n\nc = chat.chatPipeline\n</code></pre>"},{"location":"premade/#spamfilter.premade.article","title":"<code>spamfilter.premade.article</code>","text":"<p>The module containing a pre-made Pipeline class for spam filtering article-like texts.</p>"},{"location":"premade/#spamfilter.premade.article.create_pipeline","title":"<code>create_pipeline(bypass_protection: bool = True, length_filter: bool = True, min_length: int = 400, max_length: int = 300000, wordlength_filter: bool = True, max_word_length: int = 50, max_num_too_long_words: int = 3, capitals_filter: bool = True, capitals_percentage: float = 0.4, capitals_mode: str = 'normal', specialchars_filter: bool = True, profanity_filter: bool = False, profanity_blocklist_filepath: str = '')</code>","text":"<p>Create a Pipeline that is pre-made to be used in high-quality, demanding writing platforms.</p>"},{"location":"premade/#using-premadearticle","title":"Using premade.article","text":"<p>Create a Pipeline that is pre-made to be used in high-quality, demanding writing platforms.</p> <p>If you want to fine-tune your pipeline with <code>create_pipeline</code>, you are free to adjust these arguments:</p> <pre><code>from spamfilter.premade import article\n\nc = article.create_pipeline(\n    bypass_protection: bool = True,\n    length_filter: bool = True,\n    min_length: int = 400,\n    max_length: int = 300_000,\n    wordlength_filter: bool = True,\n    max_word_length: int = 50,\n    max_num_too_long_words: int = 3,\n    capitals_filter: bool = True,\n    capitals_percentage: float = 0.4,\n    capitals_mode: str = \"normal\",\n    specialchars_filter: bool = True,\n    profanity_filter: bool = False,\n    profanity_blocklist_filepath: str = \"\"\n)\n</code></pre> <p>If you want to use a default, no-setup and maybe less optimized pipeline, go for:</p> <pre><code>from spamfilter.premade import article\n\nc = chat.articlePipeline\n</code></pre>"},{"location":"results/","title":"\ud83d\udd0e Results","text":"<p>The <code>spamfilter</code> module is highly object-oriented and therefore encapsulates results of filtering runs in a <code>Result</code> object which will be constructed once a pipeline is done filtering a string.</p> <p>The Result object is made to unify returned data by pipelines and is very easy to use.</p>"},{"location":"results/#spamfilter.result.Result","title":"<code>spamfilter.result.Result</code>  <code>dataclass</code>","text":"<p>Dataclass to determine a result of a string running through a filtering pipeline.</p> <ul> <li><code>Result.passed</code>: bool whether the text passed the filters.</li> <li><code>Result.result</code>: resulting, sanitized string.</li> <li><code>Result.original</code>: the string before getting passed through the filtering pipelines.</li> <li><code>Result.changes_made</code>: how many changes have been commited to the string by the filters.</li> <li><code>Result.failed_filters</code>: the filters that made the string fail if it did.</li> </ul>"},{"location":"results/#create-your-own-result","title":"Create your own result","text":"<p>Whenever you need to create your own <code>Result</code> object, just do as follows:</p> <pre><code>from spamfilter.results import Result\n\nr = Result(...args)\n</code></pre>"}]}